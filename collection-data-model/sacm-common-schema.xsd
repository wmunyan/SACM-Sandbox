<?xml version="1.0" encoding="utf-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            xmlns:sacm="http://sacm.cisecurity.org/XMLSchema/sacm-common-6"
            xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
            targetNamespace="http://sacm.cisecurity.org/XMLSchema/sacm-common-6"
            elementFormDefault="qualified" version="6.0.0">
     <xsd:import namespace="http://www.w3.org/2000/09/xmldsig#" schemaLocation="xmldsig-core-schema.xsd"/>
     <xsd:annotation>
          <xsd:documentation>The following is a description of the common types that are shared across the different schemas within Open Vulnerability and Assessment Language (OVAL). Each type is described in detail and should provide the information necessary to understand what each represents. This document is intended for developers and assumes some familiarity with XML. A high level description of the interaction between these type is not outlined here.</xsd:documentation>
          <xsd:documentation>The OVAL Schema is maintained by the OVAL Community. For more information, including how to get involved in the project and how to submit change requests, please visit the OVAL website at http://oval.cisecurity.org.</xsd:documentation>
          <xsd:appinfo>
            <schema>Core Common</schema>
            <version>6.0.0</version>
            <date>07/10/2019 09:00:00 AM</date>
            <terms_of_use>For the portion subject to the copyright in the United States: Copyright (c) 2016 United States Government. All rights reserved. Copyright (c) 2016, Center for Internet Security. All rights reserved. The contents of this file are subject to the terms of the OVAL License located at https://oval.cisecurity.org/terms. See the OVAL License for the specific language governing permissions and limitations for use of this schema. When distributing copies of the OVAL Schema, this license header must be included.</terms_of_use>
          </xsd:appinfo>
     </xsd:annotation>
     <!-- =============================================================================== -->
     <!-- ===============================  GLOBAL ELEMENTS  ============================= -->
     <!-- =============================================================================== -->
     <xsd:element name="deprecated_info" type="sacm:DeprecatedInfoType">
          <xsd:annotation>
                <xsd:documentation>The deprecated_info element is used in documenting deprecation information for items in the OVAL Language.  It is declared globally as it can be found in any of the OVAL schemas and is used as part of the appinfo documentation and therefore it is not an element that can be declared locally and based off a global type..</xsd:documentation>
          </xsd:annotation>
     </xsd:element>
     <xsd:element name="element_mapping" type="sacm:ElementMapType">
          <xsd:annotation>
               <xsd:documentation>The element_mapping element is used in documenting which tests, objects, states, and system characteristic items are associated with each other. It provides a way to explicitly and programatically associate the test, object, state, and item definitions.</xsd:documentation>
          </xsd:annotation>
     </xsd:element>
     <xsd:element name="notes" type="sacm:NotesType">
          <xsd:annotation>
               <xsd:documentation>Element for containing notes; can be replaced using a substitution group.</xsd:documentation>
          </xsd:annotation>
     </xsd:element>
     <!-- =============================================================================== -->
     <!-- ===============================  GLOBAL TYPES  ================================ -->
     <!-- =============================================================================== -->
     <xsd:complexType name="ElementMapType">
          <xsd:annotation>
               <xsd:documentation>The ElementMapType is used to document the association between OVAL test, object, state, and item entities.</xsd:documentation>
          </xsd:annotation>
          <xsd:sequence>
               <xsd:element name="test" type="sacm:ElementMapItemType" minOccurs="1">
                    <xsd:annotation>
                         <xsd:documentation>The local name of an OVAL test.</xsd:documentation>
                    </xsd:annotation>
               </xsd:element>
               <xsd:element name="collection" type="sacm:ElementMapItemType" minOccurs="0">
                    <xsd:annotation>
                         <xsd:documentation>The local name of an OVAL object.</xsd:documentation>
                    </xsd:annotation>
               </xsd:element>
               <xsd:element name="state" type="sacm:ElementMapItemType" minOccurs="0">
                    <xsd:annotation>
                         <xsd:documentation>The local name of an OVAL state.</xsd:documentation>
                    </xsd:annotation>
               </xsd:element>
               <xsd:element name="item" type="sacm:ElementMapItemType" minOccurs="0">
                    <xsd:annotation>
                         <xsd:documentation>The local name of an OVAL item.</xsd:documentation>
                    </xsd:annotation>
               </xsd:element>
          </xsd:sequence>
     </xsd:complexType>
     <xsd:complexType name="ElementMapItemType">
          <xsd:annotation>
               <xsd:documentation>Defines a reference to an OVAL entity using the schema namespace and element name.</xsd:documentation>
          </xsd:annotation>
          <xsd:simpleContent>
               <xsd:extension base="xsd:NCName">
                    <xsd:attribute name="target_namespace" type="xsd:anyURI" use="optional" >
                         <xsd:annotation>
                              <xsd:documentation>The target_namespace attributes indicates what XML namespace the element belongs to. If not present, the namespace is that of the document in which the ElementMapItemType instance element appears.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:attribute>
               </xsd:extension>
          </xsd:simpleContent>
     </xsd:complexType>
     <xsd:complexType name="DeprecatedInfoType">
          <xsd:annotation>
                <xsd:documentation>The DeprecatedInfoType complex type defines a structure that will be used to flag schema-defined constructs as deprecated.  It holds information related to the version of OVAL when the construct was deprecated along with a reason and comment.</xsd:documentation>
          </xsd:annotation>
          <xsd:sequence>
               <xsd:element name="version">
                    <xsd:annotation>
                         <xsd:documentation>The required version child element details the version of OVAL in which the construct became deprecated.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:simpleType>
                         <xsd:restriction base="sacm:SchemaVersionPattern"/>
                    </xsd:simpleType>
               </xsd:element>
               <xsd:element name="reason" type="xsd:string">
                    <xsd:annotation>
                         <xsd:documentation>The required reason child element is used to provide an explanation as to why an item was deprecated and to direct a reader to possible alternative structures within OVAL.</xsd:documentation>
                    </xsd:annotation>
               </xsd:element>
               <xsd:element name="comment" type="xsd:string" minOccurs="0" maxOccurs="1">
                    <xsd:annotation>
                         <xsd:documentation>The optional comment child element is used to supply additional information regarding the element's deprecated status.</xsd:documentation>
                    </xsd:annotation>
               </xsd:element>
          </xsd:sequence>
     </xsd:complexType>
     <xsd:complexType name="GeneratorType">
          <xsd:annotation>
               <xsd:documentation>The GeneratorType complex type defines an element that is used to hold information about when a particular OVAL document was compiled, what version of the schema was used, what tool compiled the document, and what version of that tool was used. </xsd:documentation>
               <xsd:documentation>Additional generator information is also allowed although it is not part of the official OVAL Schema. Individual organizations can place generator information that they feel are important and these will be skipped during the validation. All OVAL really cares about is that the stated generator information is there.</xsd:documentation>
          </xsd:annotation>
          <xsd:sequence>
               <xsd:element name="product_name" type="xsd:string" minOccurs="0" maxOccurs="1">
                    <xsd:annotation>
                         <xsd:documentation>The optional product_name specifies the name of the application used to generate the file. Product names SHOULD be expressed as CPE Names according to the Common Platform Enumeration: Name Matching Specification Version 2.3.</xsd:documentation>
                    </xsd:annotation>
               </xsd:element>
               <xsd:element name="product_version" type="xsd:string" minOccurs="0" maxOccurs="1">
                    <xsd:annotation>
                         <xsd:documentation>The optional product_version specifies the version of the application used to generate the file.</xsd:documentation>
                    </xsd:annotation>
               </xsd:element>
               <xsd:element name="schema_version" maxOccurs="unbounded" type="sacm:SchemaVersionType">
                    <xsd:annotation>
                         <xsd:documentation>The required schema_version specifies the version of the OVAL Schema that the document has been written in and that should be used for validation. The versions for both the Core and any platform extensions used should be declared in separate schema_version elements.</xsd:documentation>
                    </xsd:annotation>
               </xsd:element>
               <xsd:element name="timestamp" type="xsd:dateTime">
                    <xsd:annotation>
                         <!--- TODO - Add schematron to enforce yyyy-mm-ddThh:mm:ss format -->
                         <xsd:documentation>The required timestamp specifies when the particular OVAL document was compiled. The format for the timestamp is yyyy-mm-ddThh:mm:ss. Note that the timestamp element does not specify when a definition (or set of definitions) was created or modified but rather when the actual XML document that contains the definition was created. For example, the document might have pulled a bunch of existing OVAL Definitions together, each of the definitions having been created at some point in the past. The timestamp in this case would be when the combined document was created.</xsd:documentation>
                    </xsd:annotation>
               </xsd:element>
               <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax">
               <xsd:annotation>
                    <xsd:documentation>The Asset Identification specification (http://scap.nist.gov/specifications/ai/) provides a standardized way of reporting asset information across different organizations.</xsd:documentation>
                    <xsd:documentation>Asset Identification elements can hold data useful for identifying what tool, what version of that tool was used, and identify other assets used to compile an OVAL document, such as persons or organizations.</xsd:documentation> 
                    <xsd:documentation>To support greater interoperability, an ai:assets element describing assets used to produce an OVAL document may appear at this point in an OVAL document.</xsd:documentation>
               </xsd:annotation>
               </xsd:any>
          </xsd:sequence>
     </xsd:complexType>
     <xsd:complexType name="SchemaVersionType">
          <xsd:annotation>
               <xsd:documentation>The core version MUST match on all platform schema versions.</xsd:documentation>
          </xsd:annotation>
          <xsd:simpleContent>
               <xsd:extension base="sacm:SchemaVersionPattern">
                    <xsd:attribute name="platform" type="xsd:anyURI" use="optional" >
                         <xsd:annotation>
                              <xsd:documentation>The platform attribute is available to indicate the URI of the target namespace for any platform extension being included. This platform attribute is to be omitted when specifying the core schema version.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:attribute>
               </xsd:extension>
          </xsd:simpleContent>
     </xsd:complexType>
     <xsd:complexType name="MessageType">
          <xsd:annotation>
               <xsd:documentation>The MessageType complex type defines the structure for which messages are relayed from the data collection engine. Each message is a text string that has an associated level attribute identifying the type of message being sent. These messages could be error messages, warning messages, debug messages, etc. How the messages are used by tools and whether or not they are displayed to the user is up to the specific implementation. Please refer to the description of the MessageLevelEnumeration for more information about each type of message.</xsd:documentation>
          </xsd:annotation>
          <xsd:simpleContent>
               <xsd:extension base="xsd:string">
                    <xsd:attribute name="level" type="sacm:MessageLevelEnumeration" use="optional" default="info"/>
               </xsd:extension>
          </xsd:simpleContent>
     </xsd:complexType>
     <xsd:complexType name="NotesType">
          <xsd:annotation>
               <xsd:documentation>The NotesType complex type is a container for one or more note child elements. Each note contains some information about the definition or tests that it references. A note may record an unresolved question about the definition or test or present the reason as to why a particular approach was taken.</xsd:documentation>
          </xsd:annotation>
          <xsd:sequence>
               <xsd:element name="note" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/>
          </xsd:sequence>
     </xsd:complexType>
     <!-- =============================================================================== -->
     <!-- ===============================  ENUMERATIONS  ================================ -->
     <!-- =============================================================================== -->
     <xsd:simpleType name="CheckEnumeration">
          <xsd:annotation>
               <xsd:documentation>The CheckEnumeration simple type defines acceptable check values, which are used to determine the final result of something based on the results of individual components. When used to define the relationship between objects and states, each check value defines how many of the matching objects (items except those with a status of does not exist) must satisfy the given state for the test to return true. When used to define the relationship between instances of a given entity, the different check values defines how many instances must be true for the entity to return true. When used to define the relationship between entities and multiple variable values, each check value defines how many variable values must be true for the entity to return true.</xsd:documentation>
               <xsd:appinfo>
                    <evaluation_documentation>Below are some tables that outline how each check attribute effects evaluation. The far left column identifies the check attribute in question. The middle column specifies the different combinations of individual results that the check attribute may bind together. (T=true, F=false, E=error, U=unknown, NE=not evaluated, NA=not applicable) For example, a 1+ under T means that one or more individual results are true, while a 0 under U means that zero individual results are unknown. The last column specifies what the final result would be according to each combination of individual results. Note that if the individual test is negated, then a true result is false and a false result is true, all other results stay as is.</evaluation_documentation>
                    <evaluation_chart xml:space="preserve">
               ||  num of individual results  ||
 check attr is ||                             ||  final result is
               || T  | F  | E  | U  | NE | NA ||
---------------||-----------------------------||------------------
               || 1+ | 0  | 0  | 0  | 0  | 0+ ||  True
               || 0+ | 1+ | 0+ | 0+ | 0+ | 0+ ||  False
     ALL       || 0+ | 0  | 1+ | 0+ | 0+ | 0+ ||  Error
               || 0+ | 0  | 0  | 1+ | 0+ | 0+ ||  Unknown
               || 0+ | 0  | 0  | 0  | 1+ | 0+ ||  Not Evaluated
               || 0  | 0  | 0  | 0  | 0  | 1+ ||  Not Applicable
---------------||-----------------------------||------------------
                    </evaluation_chart>
                    <evaluation_chart xml:space="preserve">
               ||  num of individual results  ||
 check attr is ||                             ||  final result is
               || T  | F  | E  | U  | NE | NA ||
---------------||-----------------------------||------------------
               || 1+ | 0+ | 0+ | 0+ | 0+ | 0+ ||  True
               || 0  | 1+ | 0  | 0  | 0  | 0+ ||  False
  AT LEAST ONE || 0  | 0+ | 1+ | 0+ | 0+ | 0+ ||  Error
               || 0  | 0+ | 0  | 1+ | 0+ | 0+ ||  Unknown
               || 0  | 0+ | 0  | 0  | 1+ | 0+ ||  Not Evaluated
               || 0  | 0  | 0  | 0  | 0  | 1+ ||  Not Applicable
---------------||-----------------------------||------------------
                    </evaluation_chart>
                    <evaluation_chart xml:space="preserve">
               ||  num of individual results  ||
 check attr is ||                             ||  final result is
               || T  | F  | E  | U  | NE | NA ||
---------------||-----------------------------||------------------
               || 1  | 0+ | 0  | 0  | 0  | 0+ ||  True
               || 2+ | 0+ | 0+ | 0+ | 0+ | 0+ ||  ** False **
               || 0  | 1+ | 0  | 0  | 0  | 0+ ||  ** False **
   ONLY ONE    ||0,1 | 0+ | 1+ | 0+ | 0+ | 0+ ||  Error
               ||0,1 | 0+ | 0  | 1+ | 0+ | 0+ ||  Unknown
               ||0,1 | 0+ | 0  | 0  | 1+ | 0+ ||  Not Evaluated
               || 0  | 0  | 0  | 0  | 0  | 1+ ||  Not Applicable
---------------||-----------------------------||------------------
                    </evaluation_chart>
                    <evaluation_chart xml:space="preserve">
               ||  num of individual results  ||
 check attr is ||                             ||  final result is
               || T  | F  | E  | U  | NE | NA ||
---------------||-----------------------------||------------------
               || 0  | 1+ | 0  | 0  | 0  | 0+ ||  True
               || 1+ | 0+ | 0+ | 0+ | 0+ | 0+ ||  False
  NONE SATISFY || 0  | 0+ | 1+ | 0+ | 0+ | 0+ ||  Error
               || 0  | 0+ | 0  | 1+ | 0+ | 0+ ||  Unknown
               || 0  | 0+ | 0  | 0  | 1+ | 0+ ||  Not Evaluated
               || 0  | 0  | 0  | 0  | 0  | 1+ ||  Not Applicable
---------------||-----------------------------||------------------
                    </evaluation_chart>
               </xsd:appinfo>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:enumeration value="all">
                    <xsd:annotation>
                         <xsd:documentation>A value of 'all' means that a final result of true is given if all the individual results under consideration are true.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="at least one">
                    <xsd:annotation>
                          <xsd:documentation>A value of 'at least one' means that a final result of true is given if at least one of the individual results under consideration is true.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="none satisfy">
                    <xsd:annotation>
                          <xsd:documentation>A value of 'none satisfy' means that a final result of true is given if none the individual results under consideration are true.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="only one">
                    <xsd:annotation>
                          <xsd:documentation>A value of 'only one' means that a final result of true is given if one and only one of the individual results under consideration are true.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
          </xsd:restriction>
     </xsd:simpleType>
     <xsd:simpleType name="ClassEnumeration">
          <xsd:annotation>
               <xsd:documentation>The ClassEnumeration simple type defines the different classes of definitions. Each class defines a certain intent regarding how an OVAL Definition is written and what that definition is describing. The specified class gives a hint about the definition so a user can know what the definition writer is trying to say. Note that the class does not make a statement about whether a true result is good or bad as this depends on the use of an OVAL Definition. These classes are also used to group definitions by the type of system state they are describing. For example, this allows users to find all the vulnerability (or patch, or inventory, etc) definitions.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:enumeration value="compliance">
                    <xsd:annotation>
                         <xsd:documentation>A compliance definition describes the state of a machine as it complies with a specific policy. A definition of this class will evaluate to true when the system is found to be compliant with the stated policy. Another way of thinking about this is that a compliance definition is stating "the system is compliant if ...".</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="inventory">
                    <xsd:annotation>
                         <xsd:documentation>An inventory definition describes whether a specific piece of software is installed on the system. A definition of this class will evaluate to true when the specified software is found on the system. Another way of thinking about this is that an inventory definition is stating "the software is installed if ...".</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="miscellaneous">
                    <xsd:annotation>
                         <xsd:documentation>The 'miscellaneous' class is used to identify definitions that do not fall into any of the other defined classes.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="patch">
                    <xsd:annotation>
                         <xsd:documentation>A patch definition details the machine state of whether a patch executable should be installed. A definition of this class will evaluate to true when the specified patch is missing from the system. Another way of thinking about this is that a patch definition is stating "the patch should be installed if ...". Note that word SHOULD is intended to mean more than just CAN the patch executable be installed. In other words, if a more recent patch is already installed then the specified patch might not need to be installed.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="vulnerability">
                    <xsd:annotation>
                         <xsd:documentation>A vulnerability definition describes the conditions under which a machine is vulnerable. A definition of this class will evaluate to true when the system is found to be vulnerable with the stated issue. Another way of thinking about this is that a vulnerability definition is stating "the system is vulnerable if ...".</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
          </xsd:restriction>
     </xsd:simpleType>
     <xsd:simpleType name="SimpleDatatypeEnumeration">
          <xsd:annotation>
               <xsd:documentation>The SimpleDatatypeEnumeration simple type defines the legal datatypes that are used to describe the values of individual entities that can be represented in a XML string field. The value may have structure and a pattern, but it is represented as string content.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:enumeration value="binary">
                    <xsd:annotation>
                         <xsd:documentation>The binary datatype is used to represent hex-encoded data that is in raw (non-printable) form. This datatype conforms to the W3C Recommendation for binary data meaning that each binary octet is encoded as a character tuple, consisting of two hexadecimal digits {[0-9a-fA-F]} representing the octet code.  Expected operations within OVAL for binary values are 'equals' and 'not equal'.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="boolean">
                    <xsd:annotation>
                         <xsd:documentation>The boolean datatype represents standard boolean data, either true or false.  This datatype conforms to the W3C Recommendation for boolean data meaning that the following literals are legal values: {true, false, 1, 0}.  Expected operations within OVAL for boolean values are 'equals' and 'not equal'.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="evr_string">
                    <xsd:annotation>
                         <xsd:documentation>The evr_string datatype represents the epoch, version, and release fields as a single version string. It has the form "EPOCH:VERSION-RELEASE". Comparisons involving this datatype should follow the algorithm of librpm's rpmvercmp() function. Expected operations within OVAL for evr_string values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="debian_evr_string">
                    <xsd:annotation>
                         <xsd:documentation>The debian_evr_string datatype represents the epoch, upstream_version, and debian_revision fields, for a Debian package, as a single version string. It has the form "EPOCH:UPSTREAM_VERSION-DEBIAN_REVISION". Comparisons involving this datatype should follow the algorithm outlined in Chapter 5 of the "Debian Policy Manual" (https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version). Note that a null epoch is equivalent to a value of '0'. An implementation of this is the cmpversions() function in dpkg's enquiry.c. Expected operations within OVAL for debian_evr_string values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="fileset_revision">
                    <xsd:annotation>
                         <xsd:documentation>The fileset_revision datatype represents the version string related to filesets in HP-UX. An example would be 'A.03.61.00'. For more information, see the HP-UX "Software Distributor Administration Guide" (http://h20000.www2.hp.com/bc/docs/support/SupportManual/c01919399/c01919399.pdf).  Expected operations within OVAL for fileset_version values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="float">
                    <xsd:annotation>
                         <xsd:documentation>The float datatype describes standard float data.  This datatype conforms to the W3C Recommendation for float data meaning it is patterned after the IEEE single-precision 32-bit floating point type.  The format consists of a decimal followed, optionally, by the character 'E' or 'e', followed by an integer exponent.  The special values positive and negative infinity and not-a-number have are represented by INF, -INF and NaN, respectively.  Expected operations within OVAL for float values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="ios_version">
                    <xsd:annotation>
                         <xsd:documentation>The ios_version datatype describes Cisco IOS Train strings. These are in essence version strings for IOS. Please refer to Cisco's IOS Reference Guide for information on how to compare different Trains as they follow a very specific pattern. Expected operations within OVAL for ios_version values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="int">
                    <xsd:annotation>
                         <xsd:documentation>The int datatype describes standard integer data.  This datatype conforms to the W3C Recommendation for integer data which follows the standard mathematical concept of the integer numbers.  (no decimal point and infinite range)  Expected operations within OVAL for int values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', 'less than or equal', 'bitwise and', and 'bitwise or'.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="ipv4_address">
                    <xsd:annotation>
                         <xsd:documentation>The ipv4_address datatype represents IPv4 addresses and IPv4 address prefixes. Its value space consists of the set of ordered pairs of integers where the first element of each pair is in the range [0,2^32) (the representable range of a 32-bit unsigned int), and the second is in the range [0,32]. The first element is an address, and the second is a prefix length. </xsd:documentation>
                         <xsd:documentation>The lexical space is dotted-quad CIDR-like notation ('a.b.c.d' where 'a', 'b', 'c', and 'd' are integers from 0-255), optionally followed by a slash ('/') and either a prefix length (an integer from 0-32) or a netmask represented in the dotted-quad notation described previously. Examples of legal values are '192.0.2.0', '192.0.2.0/32', and '192.0.2.0/255.255.255.255'. Additionally, leading zeros are permitted such that '192.0.2.0' is equal to '192.000.002.000'. If a prefix length is not specified, it is implicitly equal to 32.</xsd:documentation>
                         <xsd:documentation>The expected operations within OVAL for ipv4_address values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', 'less than or equal', 'subset of', and 'superset of'. All operations are defined in terms of the value space. Let A and B be ipv4_address values (i.e. ordered pairs from the value space). The following definitions assume that bits outside the prefix have been zeroed out. By zeroing the low order bits, they are effectively ignored for all operations. Implementations of the following operations MUST behave as if this has been done.</xsd:documentation>
                         <xsd:documentation>The following defines how to perform each operation for the ipv4_address datatype. Let P_addr mean the first element of ordered pair P and P_prefix mean the second element.</xsd:documentation>
                         <xsd:documentation>equals: A equals B if and only if A_addr == B_addr and A_prefix == B_prefix.</xsd:documentation>
                         <xsd:documentation>not equal: A is not equal to B if and only if they don't satisfy the criteria for operator "equals".</xsd:documentation>
                         <xsd:documentation>greater than: A is greater than B if and only if A_prefix == B_prefix and A_addr > B_addr. If A_prefix != B_prefix, i.e. prefix lengths are not equal, an error MUST be reported.</xsd:documentation>
                         <xsd:documentation>greater than or equal: A is greater than or equal to B if and only if A_prefix == B_prefix and they satisfy either the criteria for operators "equal" or "greater than". If A_prefix != B_prefix, i.e. prefix lengths are not equal, an error MUST be reported.</xsd:documentation>
                         <xsd:documentation>less than: A is less than B if and only if A_prefix == B_prefix and they don't satisfy the criteria for operator "greater than or equal". If A_prefix != B_prefix, i.e. prefix lengths are not equal, an error MUST be reported.</xsd:documentation>
                         <xsd:documentation>less than or equal: A is less than or equal to B if and only if A_prefix == B_prefix and they don't satisfy the criteria for operator "greater than". If A_prefix != B_prefix, i.e. prefix lengths are not equal, an error MUST be reported.</xsd:documentation>
                         <xsd:documentation>subset of: A is a subset of B if and only if every IPv4 address in subnet A is present in subnet B. In other words, A_prefix >= B_prefix and the high B_prefix bits of A_addr and B_addr are equal.</xsd:documentation>
                         <xsd:documentation>superset of: A is a superset of B if and only if B is a subset of A.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="ipv6_address">
                    <xsd:annotation>
                         <xsd:documentation>The ipv6_address datatype represents IPv6 addresses and IPv6 address prefixes. Its value space consists of the set of ordered pairs of integers where the first element of each pair is in the range [0,2^128) (the representable range of a 128-bit unsigned int), and the second is in the range [0,128]. The first element is an address, and the second is a prefix length.</xsd:documentation>
                         <xsd:documentation>The lexical space is CIDR notation given in IETF specification RFC 4291 for textual representations of IPv6 addresses and IPv6 address prefixes (see sections 2.2 and 2.3). If a prefix-length is not specified, it is implicitly equal to 128.</xsd:documentation>
                         <xsd:documentation>The expected operations within OVAL for ipv6_address values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', 'less than or equal', 'subset of', and 'superset of'. All operations are defined in terms of the value space. Let A and B be ipv6_address values (i.e. ordered pairs from the value space). The following definitions assume that bits outside the prefix have been zeroed out. By zeroing the low order bits, they are effectively ignored for all operations. Implementations of the following operations MUST behave as if this has been done.</xsd:documentation>
                         <xsd:documentation>The following defines how to perform each operation for the ipv6_address datatype. Let P_addr mean the first element of ordered pair P and P_prefix mean the second element.</xsd:documentation>
                         <xsd:documentation>equals: A equals B if and only if A_addr == B_addr and A_prefix == B_prefix.</xsd:documentation>
                         <xsd:documentation>not equal: A is not equal to B if and only if they don't satisfy the criteria for operator "equals".</xsd:documentation>   
                         <xsd:documentation>greater than: A is greater than B if and only if A_prefix == B_prefix and A_addr > B_addr. If A_prefix != B_prefix, an error MUST be reported.</xsd:documentation>
                         <xsd:documentation>greater than or equal: A is greater than or equal to B if and only if A_prefix == B_prefix and they satisfy either the criteria for operators "equal" or "greater than". If A_prefix != B_prefix, an error MUST be reported.</xsd:documentation>
                         <xsd:documentation>less than: A is less than B if and only if A_prefix == B_prefix and they don't satisfy the criteria for operator "greater than or equal". If A_prefix != B_prefix, an error MUST be reported.</xsd:documentation>
                         <xsd:documentation>less than or equal: A is less than or equal to B if and only if A_prefix == B_prefix and they don't satisfy the criteria for operator "greater than". If A_prefix != B_prefix, an error MUST be reported.</xsd:documentation>
                         <xsd:documentation>subset of: A is a subset of B if and only if every IPv6 address in subnet A is present in subnet B. In other words, A_prefix >= B_prefix and the high B_prefix bits of A_addr and B_addr are equal.</xsd:documentation>
                         <xsd:documentation>superset of: A is a superset of B if and only if B is a subset of A.</xsd:documentation>                         
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="string">
                    <xsd:annotation>
                         <xsd:documentation>The string datatype describes standard string data. This datatype conforms to the W3C Recommendation for string data.  Expected operations within OVAL for string values are 'equals', 'not equal', 'case insensitive equals', 'case insensitive not equal', 'pattern match'.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="version">
                    <xsd:annotation>
                         <xsd:documentation>The version datatype represents a value that is a hierarchical list of non-negative integers separated by a single character delimiter.  Note that any non-number character can be used as a delimiter and that different characters can be used within the same version string.  So '#.#-#' is the same as '#.#.#' or '#c#c#' where '#' is any non-negative integer.  Expected operations within OVAL for version values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.</xsd:documentation>
                         <xsd:documentation>For example '#.#.#' or '#-#-#-#' where the numbers to the left are more significant than the numbers to the right. When performing an 'equals' operation on a version datatype, you should first check the left most number for equality. If that fails, then the values are not equal. If it succeeds, then check the second left most number for equality. Continue checking the numbers from left to right until the last number has been checked. If, after testing all the previous numbers, the last number is equal then the two versions are equal. When performing other operations, such as 'less than', 'less than or equal', 'greater than, or 'greater than or equal', similar logic as above is used. Start with the left most number and move from left to right. For each number, check if it is less than the number you are testing against. If it is, then the version in question is less than the version you are testing against. If the number is equal, then move to check the next number to the right. For example, to test if 5.7.23 is less than or equal to 5.8.0 you first compare 5 to 5. They are equal so you move on to compare 7 to 8. 7 is less than 8 so the entire test succeeds and 5.7.23 is 'less than or equal' to 5.8.0. The difference between the 'less than' and 'less than or equal' operations is how the last number is handled. If the last number is reached, the check should use the given operation (either 'less than' and 'less than or equal') to test the number. For example, to test if 4.23.6 is greater than 4.23.6 you first compare 4 to 4. They are equal so you move on to compare 23 to 23. They are equal so you move on to compare 6 to 6. This is the last number in the version and since 6 is not greater than 6, the entire test fails and 4.23.6 is not greater than 4.23.6.</xsd:documentation>
                         <xsd:documentation>Version strings with a different number of components shall be padded with zeros to make them the same size. For example, if the version strings '1.2.3' and '6.7.8.9' are being compared, then the short one should be padded to become '1.2.3.0'.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
          </xsd:restriction>
     </xsd:simpleType>
     <xsd:simpleType name="ComplexDatatypeEnumeration">
          <xsd:annotation>
               <xsd:documentation>The ComplexDatatypeEnumeration simple type defines the complex legal datatypes that are supported in OVAL. These datatype describe the values of individual entities where the entity has some complex structure beyond simple string like content.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
          <xsd:enumeration value="record">
               <xsd:annotation>
                    <xsd:documentation>The record datatype describes an entity with structured set of named fields and values as its content. The only allowed operation within OVAL for record values is 'equals'. Note that the record datatype is not currently allowed when using variables.</xsd:documentation>
               </xsd:annotation>
          </xsd:enumeration>
          </xsd:restriction>
     </xsd:simpleType>
     <xsd:simpleType name="DatatypeEnumeration">
          <xsd:annotation>
               <xsd:documentation>The DatatypeEnumeration simple type defines the legal datatypes that are used to describe the values of individual entities. A value should be interpreted according to the specified type. This is most important during comparisons. For example, is '21' less than '123'? will evaluate to true if the datatypes are 'int', but will evaluate to 'false' if the datatypes are 'string'. Another example is applying the 'equal' operation to '1.0.0.0' and '1.0'. With datatype 'string' they are not equal, with datatype 'version' they are.</xsd:documentation>
          </xsd:annotation>
          <xsd:union memberTypes="sacm:SimpleDatatypeEnumeration sacm:ComplexDatatypeEnumeration"/>
     </xsd:simpleType>
     <xsd:simpleType name="ExistenceEnumeration">
          <xsd:annotation>
               <xsd:documentation>The ExistenceEnumeration simple type defines acceptable existence values, which are used to determine a result based on the existence of individual components. The main use for this is for a test regarding the existence of objects on the system. Its secondary use is for a state regarding the existence of entities in corresponding items.</xsd:documentation>
               <xsd:appinfo>
                    <evaluation_documentation>Below are some tables that outline how each ExistenceEnumeration value effects evaluation of a given test.  Note that this is related to the existence of an object(s) and not the object(s) compliance with a state.  The left column identifies the ExistenceEnumeration value in question. The middle column specifies the different combinations of individual item status values that have been found in the system characteristics file related to the given object. (EX=exists, DE=does not exist, ER=error, NC=not collected) For example, a 1+ under EX means that one or more individual item status attributes are set to exists, while a 0 under NC means that zero individual item status attributes are set to not collected.  The last column specifies what the result of the existence piece would be according to each combination of individual item status values.</evaluation_documentation>
                    <evaluation_chart xml:space="preserve">
                    ||  item status value count  ||
       attr value   ||                           || existence piece is
                    ||  EX  |  DE  |  ER  |  NC  ||
--------------------||---------------------------||------------------
                    ||  1+  |  0   |  0   |  0   ||  True
                    ||  0   |  0   |  0   |  0   ||  False
                    ||  0+  |  1+  |  0+  |  0+  ||  False  
        all_exist   ||  0+  |  0   |  1+  |  0+  ||  Error
                    ||  0+  |  0   |  0   |  1+  ||  Unknown
                    ||  --  |  --  |  --  |  --  ||  Not Evaluated
                    ||  --  |  --  |  --  |  --  ||  Not Applicable
--------------------||---------------------------||------------------
                    </evaluation_chart>
                    <evaluation_chart xml:space="preserve">
                    ||  item status value count  ||
       attr value   ||                           ||  existence piece is
                    ||  EX  |  DE  |  ER  |  NC  ||
--------------------||---------------------------||------------------
                    ||  0+  |  0+  |  0   |  0+  ||  True 
                    ||  1+  |  0+  |  1+  |  0+  ||  True
                    ||  --  |  --  |  --  |  --  ||  False
        any_exist   ||  0   |  0+  |  1+  |  0+  ||  Error
                    ||  --  |  --  |  --  |  --  ||  Unknown
                    ||  --  |  --  |  --  |  --  ||  Not Evaluated
                    ||  --  |  --  |  --  |  --  ||  Not Applicable
--------------------||---------------------------||------------------
                    </evaluation_chart>
                    <evaluation_chart xml:space="preserve">
                    ||  item status value count  ||
       attr value   ||                           ||  existence piece is
                    ||  EX  |  DE  |  ER  |  NC  ||
--------------------||---------------------------||------------------
                    ||  1+  |  0+  |  0+  |  0+  ||  True 
                    ||  0   |  0+  |  0   |  0   ||  False
at_least_one_exists ||  0   |  0+  |  1+  |  0+  ||  Error
                    ||  0   |  0+  |  0   |  1+  ||  Unknown
                    ||  --  |  --  |  --  |  --  ||  Not Evaluated
                    ||  --  |  --  |  --  |  --  ||  Not Applicable
--------------------||---------------------------||------------------
                    </evaluation_chart>
                    <evaluation_chart xml:space="preserve">
                    ||  item status value count  ||
       attr value   ||                           ||  existence piece is
                    ||  EX  |  DE  |  ER  |  NC  ||
--------------------||---------------------------||------------------
                    ||  0   |  0+  |  0   |  0   ||  True 
                    ||  1+  |  0+  |  0+  |  0+  ||  False
       none_exist   ||  0   |  0+  |  1+  |  0+  ||  Error
                    ||  0   |  0+  |  0   |  1+  ||  Unknown
                    ||  --  |  --  |  --  |  --  ||  Not Evaluated
                    ||  --  |  --  |  --  |  --  ||  Not Applicable
--------------------||---------------------------||------------------
                    </evaluation_chart>
                    <evaluation_chart xml:space="preserve">
                    ||  item status value count  ||
       attr value   ||                           ||  existence piece is
                    ||  EX  |  DE  |  ER  |  NC  ||
--------------------||---------------------------||------------------
                    ||  1   |  0+  |  0   |  0   ||  True 
                    ||  2+  |  0+  |  0+  |  0+  ||  False
                    ||  0   |  0+  |  0   |  0   ||  False
  only_one_exists   ||  0,1 |  0+  |  1+  |  0+  ||  Error
                    ||  0,1 |  0+  |  0   |  1+  ||  Unknown
                    ||  --  |  --  |  --  |  --  ||  Not Evaluated
                    ||  --  |  --  |  --  |  --  ||  Not Applicable
--------------------||---------------------------||------------------
                    </evaluation_chart>
               </xsd:appinfo>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:enumeration value="all_exist">
                    <xsd:annotation>
                         <xsd:documentation>When used in the context of an OVAL state entity's check_existence attribute, a value of 'all_exist' means that every item entity for an object defined by the description exists on the system. When used in the context of an OVAL test's check_existence attribute, this value is equivalent to 'at_least_one_exists' because non-existent items have no impact upon evaluation.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="any_exist">
                    <xsd:annotation>
                         <xsd:documentation>A value of 'any_exist' means that zero or more objects defined by the description exist on the system.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="at_least_one_exists">
                    <xsd:annotation>
                         <xsd:documentation>A value of 'at_least_one_exists' means that at least one object defined by the description exists on the system.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="none_exist">
                    <xsd:annotation>
                         <xsd:documentation>A value of 'none_exist' means that none of the objects defined by the description exist on the system.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="only_one_exists">
                    <xsd:annotation>
                         <xsd:documentation>A value of 'only_one_exists' means that only one object defined by the description exists on the system.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
          </xsd:restriction>
     </xsd:simpleType>
     <xsd:simpleType name="FamilyEnumeration">
          <xsd:annotation>
               <xsd:documentation>The FamilyEnumeration simple type is a listing of families that OVAL supports at this time.  Since new family values can only be added with new version of the schema, the value of 'undefined' is to be used when the desired family is not available.  Note that use of the undefined family value does not target all families, rather it means that some family other than one of the defined values is targeted.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:enumeration value="android">
                    <xsd:annotation>
                         <xsd:documentation>The android value describes the Android mobile operating system.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="asa">
                    <xsd:annotation>
                         <xsd:documentation>The asa value describes the Cisco ASA security devices.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="apple_ios">
                    <xsd:annotation>
                         <xsd:documentation>The apple_ios value describes the iOS mobile operating system.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="catos">
                    <xsd:annotation>
                         <xsd:documentation>The catos value describes the Cisco CatOS operating system.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="ios">
                    <xsd:annotation>
                         <xsd:documentation>The ios value describes the Cisco IOS operating system.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="iosxe">
                    <xsd:annotation>
                         <xsd:documentation>The iosxe value describes the Cisco IOS XE operating system.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="junos">
                    <xsd:annotation>
                         <xsd:documentation>The junos value describes the Juniper JunOS operating system.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="macos">
                    <xsd:annotation>
                         <xsd:documentation>The macos value describes the Mac operating system.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="pixos">
                    <xsd:annotation>
                         <xsd:documentation>The pixos value describes the Cisco PIX operating system.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="undefined">
                    <xsd:annotation>
                         <xsd:documentation>The undefined value is to be used when the desired family is not available.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="unix">
                    <xsd:annotation>
                         <xsd:documentation>The unix value describes the UNIX operating system.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="vmware_infrastructure">
                    <xsd:annotation>
                         <xsd:documentation>The vmware_infrastructure value describes VMWare Infrastructure.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="windows">
                    <xsd:annotation>
                         <xsd:documentation>The windows value describes the Microsoft Windows operating system.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>               
          </xsd:restriction>
     </xsd:simpleType>
     <xsd:simpleType name="MessageLevelEnumeration">
          <xsd:annotation>
               <xsd:documentation>The MessageLevelEnumeration simple type defines the different levels associated with a message. There is no specific criteria about which messages get assigned which level. This is completely arbitrary and up to the content producer to decide what is an error message and what is a debug message.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:enumeration value="debug">
                    <xsd:annotation>
                         <xsd:documentation>Debug messages should only be displayed by a tool when run in some sort of verbose mode.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="error">
                    <xsd:annotation>
                         <xsd:documentation>Error messages should be recorded when there was an error that did not allow the collection of specific data.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="fatal">
                    <xsd:annotation>
                         <xsd:documentation>A fatal message should be recorded when an error causes the failure of more than just a single piece of data.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="info">
                    <xsd:annotation>
                         <xsd:documentation>Info messages are used to pass useful information about the data collection to a user.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="warning">
                    <xsd:annotation>
                         <xsd:documentation>A warning message reports something that might not correct but information was still collected.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
          </xsd:restriction>
     </xsd:simpleType>
     <xsd:simpleType name="OperationEnumeration">
          <xsd:annotation>
               <xsd:documentation>The OperationEnumeration simple type defines acceptable operations. Each operation defines how to compare entities against their actual values.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:enumeration value="equals">
                    <xsd:annotation>
                         <xsd:documentation>The 'equals' operation returns true if the actual value on the system is equal to the stated entity.  When the specified datatype is a string, this results in a case-sensitive comparison.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
                <xsd:enumeration value="not equal">
                    <xsd:annotation>
                          <xsd:documentation>The 'not equal' operation returns true if the actual value on the system is not equal to the stated entity.  When the specified datatype is a string, this results in a case-sensitive comparison.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
                <xsd:enumeration value="case insensitive equals">
                      <xsd:annotation>
                            <xsd:documentation>The 'case insensitive equals' operation is meant for string data and returns true if the actual value on the system is equal (using a case insensitive comparison) to the stated entity.</xsd:documentation>
                      </xsd:annotation>
                </xsd:enumeration>
                <xsd:enumeration value="case insensitive not equal">
                      <xsd:annotation>
                            <xsd:documentation>The 'case insensitive not equal' operation is meant for string data and returns true if the actual value on the system is not equal (using a case insensitive comparison) to the stated entity.</xsd:documentation>
                      </xsd:annotation>
                </xsd:enumeration>
                <xsd:enumeration value="greater than">
                    <xsd:annotation>
                         <xsd:documentation>The 'greater than' operation returns true if the actual value on the system is greater than the stated entity.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="less than">
                    <xsd:annotation>
                         <xsd:documentation>The 'less than' operation returns true if the actual value on the system is less than the stated entity.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="greater than or equal">
                    <xsd:annotation>
                         <xsd:documentation>The 'greater than or equal' operation returns true if the actual value on the system is greater than or equal to the stated entity.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="less than or equal">
                    <xsd:annotation>
                         <xsd:documentation>The 'less than or equal' operation returns true if the actual value on the system is less than or equal to the stated entity.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="bitwise and">
                    <xsd:annotation>
                         <xsd:documentation>The 'bitwise and' operation is used to determine if a specific bit is set. It returns true if performing a BITWISE AND with the binary representation of the stated entity against the binary representation of the actual value on the system results in a binary value that is equal to the binary representation of the stated entity. For example, assuming a datatype of 'int', if the actual integer value of the setting on your machine is 6 (same as 0110 in binary), then performing a 'bitwise and' with the stated integer 4 (0100) returns 4 (0100). Since the result is the same as the state mask, then the test returns true. If the actual value on your machine is 1 (0001), then the 'bitwise and' with the stated integer 4 (0100) returns 0 (0000). Since the result is not the same as the stated mask, then the test fails.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="bitwise or">
                    <xsd:annotation>
                         <xsd:documentation>The 'bitwise or' operation is used to determine if a specific bit is not set. It returns true if performing a BITWISE OR with the binary representation of the stated entity against the binary representation of the actual value on the system results in a binary value that is equal to the binary representation of the stated entity. For example, assuming a datatype of 'int', if the actual integer value of the setting on your machine is 6 (same as 0110 in binary), then performing a 'bitwise or' with the stated integer 14 (1110) returns 14 (1110). Since the result is the same as the state mask, then the test returns true. If the actual value on your machine is 1 (0001), then the 'bitwise or' with the stated integer 14 (1110) returns 15 (1111). Since the result is not the same as the stated mask, then the test fails.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="pattern match">
                    <xsd:annotation>
                         <xsd:documentation>The 'pattern match' operation allows an item to be tested against a regular expression. When used by an entity in an OVAL Object, the regular expression represents the unique set of matching items on the system.  OVAL supports a common subset of the regular expression character classes, operations, expressions and other lexical tokens defined within Perl 5's regular expression specification. For more information on the supported regular expression syntax in OVAL see: http://oval.mitre.org/language/about/re_support_5.6.html</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="subset of">
                    <xsd:annotation>
                         <xsd:documentation>The 'subset of' operation returns true if the actual set on the system is a subset of the set defined by the stated entity.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="superset of">
                    <xsd:annotation>
                         <xsd:documentation>The 'superset of' operation returns true if the actual set on the system is a superset of the set defined by the stated entity.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
          </xsd:restriction>
     </xsd:simpleType>
     <xsd:simpleType name="OperatorEnumeration">
          <xsd:annotation>
               <xsd:documentation>The OperatorEnumeration simple type defines acceptable operators. Each operator defines how to evaluate multiple arguments.</xsd:documentation>
               <xsd:appinfo>
                    <evaluation_documentation>Below are some tables that outline how each operator effects evaluation. The far left column identifies the operator in question. The middle column specifies the different combinations of individual results that the operator may bind together. (T=true, F=false, E=error, U=unknown, NE=not evaluated, NA=not applicable) For example, a 1+ under T means that one or more individual results are true, while a 0 under U means that zero individual results are unknown. The last column specifies what the final result would be according to each combination of individual results. Note that if the individual test is negated, then a true result is false and a false result is true, all other results stay as is.</evaluation_documentation>
                    <evaluation_chart xml:space="preserve">
               ||  num of individual results  ||
  operator is  ||                             ||  final result is
               || T  | F  | E  | U  | NE | NA ||
---------------||-----------------------------||------------------
               || 1+ | 0  | 0  | 0  | 0  | 0+ ||  True
               || 0+ | 1+ | 0+ | 0+ | 0+ | 0+ ||  False
      AND      || 0+ | 0  | 1+ | 0+ | 0+ | 0+ ||  Error
               || 0+ | 0  | 0  | 1+ | 0+ | 0+ ||  Unknown
               || 0+ | 0  | 0  | 0  | 1+ | 0+ ||  Not Evaluated
               || 0  | 0  | 0  | 0  | 0  | 1+ ||  Not Applicable
---------------||-----------------------------||------------------
                    </evaluation_chart>
                    <evaluation_chart xml:space="preserve">
               ||  num of individual results  || 
  operator is  ||                             ||  final result is
               || T  | F  | E  | U  | NE | NA ||
---------------||-----------------------------||------------------
               || 1  | 0+ | 0  | 0  | 0  | 0+ ||  True
               || 2+ | 0+ | 0+ | 0+ | 0+ | 0+ ||  ** False **
               || 0  | 1+ | 0  | 0  | 0  | 0+ ||  ** False **
      ONE      ||0,1 | 0+ | 1+ | 0+ | 0+ | 0+ ||  Error
               ||0,1 | 0+ | 0  | 1+ | 0+ | 0+ ||  Unknown
               ||0,1 | 0+ | 0  | 0  | 1+ | 0+ ||  Not Evaluated
               || 0  | 0  | 0  | 0  | 0  | 1+ ||  Not Applicable
---------------||-----------------------------||------------------
                    </evaluation_chart>
                    <evaluation_chart xml:space="preserve">
               ||  num of individual results  || 
  operator is  ||                             ||  final result is
               || T  | F  | E  | U  | NE | NA ||
---------------||-----------------------------||------------------
               || 1+ | 0+ | 0+ | 0+ | 0+ | 0+ ||  True
               || 0  | 1+ | 0  | 0  | 0  | 0+ ||  False
      OR       || 0  | 0+ | 1+ | 0+ | 0+ | 0+ ||  Error
               || 0  | 0+ | 0  | 1+ | 0+ | 0+ ||  Unknown
               || 0  | 0+ | 0  | 0  | 1+ | 0+ ||  Not Evaluated
               || 0  | 0  | 0  | 0  | 0  | 1+ ||  Not Applicable
---------------||-----------------------------||------------------
                    </evaluation_chart>
                    <evaluation_chart xml:space="preserve">
               ||  num of individual results  ||
  operator is  ||                             ||  final result is
               || T  | F  | E  | U  | NE | NA ||
---------------||-----------------------------||------------------
               ||odd | 0+ | 0  | 0  | 0  | 0+ ||  True
               ||even| 0+ | 0  | 0  | 0  | 0+ ||  False
      XOR      || 0+ | 0+ | 1+ | 0+ | 0+ | 0+ ||  Error
               || 0+ | 0+ | 0  | 1+ | 0+ | 0+ ||  Unknown
               || 0+ | 0+ | 0  | 0  | 1+ | 0+ ||  Not Evaluated
               || 0  | 0  | 0  | 0  | 0  | 1+ ||  Not Applicable
---------------||-----------------------------||------------------
                    </evaluation_chart>
               </xsd:appinfo>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:enumeration value="AND">
                    <xsd:annotation>
                         <xsd:documentation>The AND operator produces a true result if every argument is true. If one or more arguments are false, the result of the AND is false. If one or more of the arguments are unknown, and if none of the arguments are false, then the AND operator produces a result of unknown.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="ONE">
                    <xsd:annotation>
                         <xsd:documentation>The ONE operator produces a true result if one and only one argument is true. If there are more than argument is true (or if there are no true arguments), the result of the ONE is false. If one or more of the arguments are unknown, then the ONE operator produces a result of unknown.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="OR">
                    <xsd:annotation>
                         <xsd:documentation>The OR operator produces a true result if one or more arguments is true. If every argument is false, the result of the OR is false. If one or more of the arguments are unknown and if none of arguments are true, then the OR operator produces a result of unknown.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="XOR">
                    <xsd:annotation>
                         <xsd:documentation>XOR is defined to be true if an odd number of its arguments are true, and false otherwise. If any of the arguments are unknown, then the XOR operator produces a result of unknown.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
          </xsd:restriction>
     </xsd:simpleType>
     <!-- =============================================================================== -->
     <!-- ================================  ID PATTERNS  ================================ -->
     <!-- =============================================================================== -->
     <xsd:simpleType name="DefinitionIDPattern">
          <xsd:annotation>
               <xsd:documentation>Define the format for acceptable OVAL Definition ids. An urn format is used with the id starting with the word oval followed by a unique string, followed by the three letter code 'def', and ending with an integer.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:pattern value="sacm:[A-Za-z0-9_\-\.]+:def:[1-9][0-9]*"/>
          </xsd:restriction>
     </xsd:simpleType>
     <xsd:simpleType name="CollectionIDPattern">
          <xsd:annotation>
               <xsd:documentation>Define the format for acceptable SACM Collection ids. An urn format is used with the id starting with the word oval followed by a unique string, followed by the three letter code 'col', and ending with an integer.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:pattern value="sacm:[A-Za-z0-9_\-\.]+:col:[1-9][0-9]*"/>
          </xsd:restriction>
     </xsd:simpleType>
     <xsd:simpleType name="StateIDPattern">
          <xsd:annotation>
               <xsd:documentation>Define the format for acceptable OVAL State ids. An urn format is used with the id starting with the word oval followed by a unique string, followed by the three letter code 'ste', and ending with an integer.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:pattern value="sacm:[A-Za-z0-9_\-\.]+:ste:[1-9][0-9]*"/>
          </xsd:restriction>
     </xsd:simpleType>
     <xsd:simpleType name="TestIDPattern">
          <xsd:annotation>
               <xsd:documentation>Define the format for acceptable OVAL Test ids. An urn format is used with the id starting with the word oval followed by a unique string, followed by the three letter code 'tst', and ending with an integer.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:pattern value="sacm:[A-Za-z0-9_\-\.]+:tst:[1-9][0-9]*"/>
          </xsd:restriction>
     </xsd:simpleType>
     <xsd:simpleType name="VariableIDPattern">
          <xsd:annotation>
               <xsd:documentation>Define the format for acceptable OVAL Variable ids. An urn format is used with the id starting with the word oval followed by a unique string, followed by the three letter code 'var', and ending with an integer.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:pattern value="sacm:[A-Za-z0-9_\-\.]+:var:[1-9][0-9]*"/>
          </xsd:restriction>
     </xsd:simpleType>
     <xsd:simpleType name="ItemIDPattern">
          <xsd:annotation>
               <xsd:documentation>Define the format for acceptable OVAL Item ids. The format is an integer. An item id is used to identify the different items found in an OVAL System Characteristics file.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:integer"/>
     </xsd:simpleType>
     <xsd:simpleType name="SchemaVersionPattern">
          <xsd:annotation>
               <xsd:documentation>Define the format for acceptable OVAL Language version strings.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:pattern value="[0-9]+\.[0-9]+(\.[0-9]+)?(:[0-9]+\.[0-9]+(\.[0-9]+)?)?"/>
          </xsd:restriction>
     </xsd:simpleType>
     <xsd:simpleType name="FilterIDPattern">
          <xsd:annotation>
               <xsd:documentation>Define the format for acceptable OVAL Filter ids. An urn format is used with the id starting with the word oval followed by a unique string, followed by the three letter code 'flt', and ending with an integer.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:pattern value="sacm:[A-Za-z0-9_\-\.]+:flt:[1-9][0-9]*"/>
          </xsd:restriction>
     </xsd:simpleType>
     <!-- =============================================================================== -->
     <!-- ================================  OTHER TYPES  ================================ -->
     <!-- =============================================================================== -->
     <xsd:simpleType name="EmptyStringType">
          <xsd:annotation>
               <xsd:documentation>The EmptyStringType simple type is a restriction of the built-in string simpleType. The only allowed string is the empty string with a length of zero. This type is used by certain elements to allow empty content when non-string data is accepted. See the EntityIntType in the OVAL Definition Schema for an example of its use.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:maxLength value="0"/>
          </xsd:restriction>
     </xsd:simpleType>
     <xsd:simpleType name="NonEmptyStringType">
          <xsd:annotation>
               <xsd:documentation>The NonEmptyStringType simple type is a restriction of the built-in string simpleType. Empty strings are not allowed. This type is used by comment attributes where an empty value is not allowed.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:minLength value="1"/>
          </xsd:restriction>
     </xsd:simpleType>
     <!-- =============================================================================== -->
     <!-- ===============================  ENTITY TYPES  ================================ -->
     <!-- =============================================================================== -->
     <xsd:attributeGroup name="EntityAttributeGroup">
          <xsd:annotation>
               <xsd:documentation>The EntityAttributeGroup is a collection of attributes that are common to all entities. This group defines these attributes and their default values. Individual entities may limit allowed values for these attributes, but all entities will support these attributes.</xsd:documentation>
          </xsd:annotation>
          <xsd:attribute name="datatype" type="sacm:DatatypeEnumeration" use="optional" default="string">
               <xsd:annotation>
                    <xsd:documentation>The optional datatype attribute specifies how the given operation should be applied to the data. Since we are dealing with XML everything is technically a string, but often the value is meant to represent some other datatype and this affects the way an operation is performed. For example, with the statement 'is 123 less than 98'. If the data is treated as integers the answer is no, but if the data is treated as strings, then the answer is yes. Specifying a datatype defines how the less than operation should be performed. Another way of thinking of things is that the datatype attribute specifies how the data should be cast before performing the operation (note that the default datatype is 'string'). In the previous example, if the datatype is set to int, then '123' and '98' should be cast as integers. Another example is applying the 'equals' operation to '1.0.0.0' and '1.0'. With datatype 'string' they are not equal, with datatype 'version' they are. Note that there are certain cases where a cast from one datatype to another is not possible. If a cast cannot be made, (trying to cast 'abc' to an integer) then an error should be reported. For example, if the datatype is set to 'integer' and the value is the empty string. There is no way to cast the empty string (or NULL) to an integer, and in cases like this an error should be reported.</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="operation" type="sacm:OperationEnumeration" use="optional" default="equals">
               <xsd:annotation>
                    <xsd:documentation>The optional operation attribute determines how the individual entities should be evaluated (the default operation is 'equals').</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="mask" type="xsd:boolean" use="optional" default="false">
               <xsd:annotation>
                    <xsd:documentation>The optional mask attribute is used to identify values that have been hidden for sensitivity concerns.
                         This is used by the Result document which uses the System Characteristics schema to format the information found on a specific system.
                         When the mask attribute is set to 'true' on an OVAL Entity or an OVAL Field, the corresponding collected value of that OVAL Entity or OVAL Field MUST NOT be present in the "results" section of the OVAL Results document; the "oval_definitions" section must not be altered and must be an exact copy of the definitions evaluated.
                         Values MUST NOT be masked in OVAL System Characteristics documents that are not contained within an OVAL Results document.
                         It is possible for masking conflicts to occur where one entity has mask set to true and another entity has mask set to false.
                         A conflict will occur when the mask attribute is set differently on an OVAL Object and matching OVAL State or when more than one OVAL Objects identify the same OVAL Item(s).
                         When such a conflict occurs the result is always to mask the entity.</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="var_ref" type="sacm:VariableIDPattern" use="optional">
               <xsd:annotation>
                    <xsd:documentation>The optional var_ref attribute refers the value of the element to a variable element. When supplied, the value(s) associated with the OVAL Variable should be used as the value(s) of the element. If there is an error computing the value of the variable, then that error should be passed up to the element referencing it. If the variable being referenced does not have a value (for example, if the variable pertains to the size of a file, but the file does not exist) then one of two results are possible. If the element is part of an object declaration, then the object element referencing it is considered to not exist. If the element is part of a state declaration, then the state element referencing it will evaluate to error.</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="var_check" type="sacm:CheckEnumeration" use="optional">
               <xsd:annotation>
                    <xsd:documentation>The optional var_check attribute specifies how data collection or state evaluation should proceed when an element uses a var_ref attribute, and the associated variable defines more than one value. For example, if an object entity 'filename' with an operation of 'not equal' references a variable that returns five different values, and the var_check attribute has a value of 'all', then an actual file on the system matches only if the actual filename does not equal any of the variable values. As another example, if a state entity 'size' with an operation of 'less than' references a variable that has five different integer values, and the var_check attribute has a value of 'all', then the 'size' state entity evaluates to true only if the corresponding 'size' item entity is less than each of the five integers defined by the variable. If a variable does not have any value value when referenced by an OVAL Object the object should be considered to not exist.
                         If a variable does not have any value when referenced by an OVAL State an error should be reported during OVAL analysis. When an OVAL State uses a var_ref, if both the state entity and a corresponding item entity are collections of values, the var_check is applied to each value of the item entity individually, and all must evaluate to true for the state entity to evaluate to true. In this condition, there is no value of var_check which enables an element-wise comparison, and so there is no way to determine whether the two entities are truly 'equal' in that sense. If var_ref is present but var_check is not, the element should be processed as if var_check has the value "all".</xsd:documentation>        
               </xsd:annotation>
          </xsd:attribute>
     </xsd:attributeGroup>
     <xsd:complexType name="EntitySimpleBaseType" abstract="true">
          <xsd:annotation>
               <xsd:documentation>The EntitySimpleBaseType complex type is an abstract type that defines the default attributes associated with every simple entity. Entities can be found in both OVAL Objects and OVAL States and represent the individual properties associated with items found on a system. An example of a single entity would be the path of a file. Another example would be the version of the file.</xsd:documentation>
          </xsd:annotation>
          <xsd:simpleContent>
               <xsd:extension base="xsd:anySimpleType">
                    <xsd:attributeGroup ref="sacm:EntityAttributeGroup"/>
               </xsd:extension>
          </xsd:simpleContent>
     </xsd:complexType>
     <xsd:complexType name="EntityComplexBaseType" abstract="true">
          <xsd:annotation>
               <xsd:documentation>The EntityComplexBaseType complex type is an abstract type that defines the default attributes associated with every complex entity. Entities can be found in both OVAL Objects and OVAL States and represent the individual properties associated with items found on a system. An example of a single entity would be the path of a file. Another example would be the version of the file.</xsd:documentation>
          </xsd:annotation>
          <xsd:attributeGroup ref="sacm:EntityAttributeGroup"/>
     </xsd:complexType>

     <!-- =============================================================================== -->
     <!-- ===============================  ENUMERATIONS  ================================ -->
     <!-- =============================================================================== -->
     <xsd:simpleType name="ArithmeticEnumeration">
          <xsd:annotation>
               <xsd:documentation>The ArithmeticEnumeration simple type defines basic arithmetic operations.  Currently add and multiply are defined.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:enumeration value="add"/>
               <xsd:enumeration value="multiply"/>
               <!--
                NOTE - we need to add a required position attribute to the components before we
                can have a subtract or divide function.  This will have to wait for the next
                major release
                
                <xsd:enumeration value="divide"/>
                <xsd:enumeration value="subtract"/>
            -->
          </xsd:restriction>
     </xsd:simpleType>
     <xsd:simpleType name="DateTimeFormatEnumeration">
          <xsd:annotation>
               <xsd:documentation>The DateTimeFormatEnumeration simple type defines the different date-time formats that are understood by OVAL. Note that in some cases there are a few different possibilities within a given format. Each of these possibilities is unique though and can be distinguished from each other. The different formats are used to clarify the higher level structure of the date-time string being used.</xsd:documentation>
          </xsd:annotation>
          <xsd:restriction base="xsd:string">
               <xsd:enumeration value="year_month_day">
                    <xsd:annotation>
                         <xsd:documentation>The year_month_day value specifies date-time strings that follow the formats: 'yyyymmdd', 'yyyymmddThhmmss', 'yyyy/mm/dd hh:mm:ss', 'yyyy/mm/dd', 'yyyy-mm-dd hh:mm:ss', or 'yyyy-mm-dd'</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="month_day_year">
                    <xsd:annotation>
                         <xsd:documentation>The month_day_year value specifies date-time strings that follow the formats: 'mm/dd/yyyy hh:mm:ss', 'mm/dd/yyyy', 'mm-dd-yyyy hh:mm:ss', 'mm-dd-yyyy', 'NameOfMonth, dd yyyy hh:mm:ss' or 'NameOfMonth, dd yyyy', 'AbreviatedNameOfMonth, dd yyyy hh:mm:ss', or 'AbreviatedNameOfMonth, dd yyyy'</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="day_month_year">
                    <xsd:annotation>
                         <xsd:documentation>The day_month_year value specifies date-time strings that follow the formats: 'dd/mm/yyyy hh:mm:ss', 'dd/mm/yyyy', 'dd-mm-yyyy hh:mm:ss', or 'dd-mm-yyyy'</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="win_filetime">
                    <xsd:annotation>
                         <xsd:documentation>The win_filetime value specifies date-time strings that follow the windows file time format.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="seconds_since_epoch">
                    <xsd:annotation>
                         <xsd:documentation>The seconds_since_epoch value specifies date-time values that represent the time in seconds since the UNIX epoch.  The Unix epoch is the time 00:00:00 UTC on January 1, 1970.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
               <xsd:enumeration value="cim_datetime">
                    <xsd:annotation>
                         <xsd:documentation>The cim_datetime model is used by WMI and its value specifies date-time strings that follow the format: 'yyyymmddHHMMSS.mmmmmmsUUU', and alternatively 'yyyy-mm-dd HH:MM:SS:mmm' only when used in WMI Query Language queries.</xsd:documentation>
                    </xsd:annotation>
               </xsd:enumeration>
          </xsd:restriction>
     </xsd:simpleType>
     
     <!-- =============================================================================== -->
    <!-- =================================  VARIABLES  ================================= -->
    <!-- =============================================================================== -->
    <xsd:complexType name="VariablesType">
        <xsd:annotation>
            <xsd:documentation>The VariablesType complex type is a container for one or more variable child elements. Each variable element is a way to define one or more values to be obtained at the time a definition is evaluated.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element ref="sacm:variable" minOccurs="1" maxOccurs="unbounded"/>
        </xsd:sequence>
    </xsd:complexType>
    <xsd:element name="variable" type="sacm:VariableType" abstract="true">
        <xsd:annotation>
            <xsd:documentation>The variable element is an abstract element that is meant to be extended (via substitution groups) by the different types of variables. An actual variable element is not valid.
                The different variable types describe different sources for obtaining a value(s) for the variable. There are currently three types of variables; local, external, and constant.
                Please refer to the description of each one for more specific information. The value(s) of a variable is treated as if it were inserted where referenced. 
                One of the main benefits of variables is that they allow tests to evaluate user-defined policy. 
                For example, an OVAL Test might check to see if a password is at least a certain number of characters long, but this number depends upon the individual policy of the user. 
                To solve this, the test for password length can be written to refer to a variable element that defines the length.</xsd:documentation>
            <xsd:documentation>If a variable defines a collection of values, any entity that references the variable will evaluate to true depending on the value of the var_check attribute.
                For example, if an entity 'size' with an operation of 'less than' references a variable that returns five different integers, and the var_check attribute has a value of 'all', then the 'size' entity returns true only if the actual size is less than each of the five integers defined by the variable.
                If a variable does not return any value, then an error should be reported during OVAL analysis.</xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="VariableType">
        <xsd:annotation>
            <xsd:documentation>The VariableType complex type defines attributes associated with each OVAL Variable.
                The required id attribute uniquely identifies each variable, and must conform to the format specified by the VariableIDPattern simple type.
                The required version attribute holds the current version of the variable. Versions are integers, starting at 1 and incrementing every time a variable is modified. 
                The required comment attribute provides a short description of the variable.
                The optional deprecated attribute signifies that an id is no longer to be used or referenced but the information has been kept around for historic purposes.</xsd:documentation>
            <xsd:documentation>The required datatype attribute specifies the type of value being defined.  The set of values identified by a variable must comply with the specified datatype, otherwise an error should be reported.
                Please see the DatatypeEnumeration for details about each valid datatype.  For example, if the datatype of the variable is specified as boolean then the value(s) returned by the component / function should be "true", "false", "1", or "0".</xsd:documentation>
            <xsd:documentation>Note that the 'record' datatype is not permitted on variables. The notes section of a variable should be used to hold information that might be helpful to someone examining the technical aspects of the variable. Please refer to the description of the NotesType complex type for more information about the notes element.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element ref="ds:Signature" minOccurs="0" maxOccurs="1"/>
            <xsd:element ref="sacm:notes" minOccurs="0" maxOccurs="1"/>
        </xsd:sequence>
        <xsd:attribute name="id" type="sacm:VariableIDPattern" use="required"/>
        <xsd:attribute name="version" type="xsd:nonNegativeInteger" use="required"/>
        <xsd:attribute name="datatype" use="required" type="sacm:SimpleDatatypeEnumeration">
            <xsd:annotation>
                <xsd:documentation>Note that the 'record' datatype is not permitted on variables.</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="comment" type="sacm:NonEmptyStringType" use="required"/>
        <xsd:attribute name="deprecated" type="xsd:boolean" use="optional" default="false"/>
    </xsd:complexType>
    <xsd:element name="external_variable" substitutionGroup="sacm:variable">
        <xsd:annotation>
            <xsd:documentation>The external_variable element extends the VariableType and defines a variable with some external source.
                The actual value(s) for the variable is not provided within the OVAL file, but rather it is retrieved during the evaluation of the OVAL Definition from an external source.
                An unbounded set of possible-value and possible_restriction child elements can be specified that together specify the list of all possible values that an external source is allowed to supply for the external variable.
                In other words, the value assigned by an external source must match one of the possible_value or possible_restriction elements specified.
                Each possible_value element contains a single value that could be assigned to the given external_variable while each possible_restriction element outlines a range of possible values. Note that it is not necessary to declare a variable's possible values, but the option is available if desired. If no possible child elements are specified, then the valid values are only bound to the specified datatype of the external variable. Please refer to the description of the PossibleValueType and PossibleRestrictionType complex types for more information.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="sacm:VariableType">
                    <xsd:choice minOccurs="0" maxOccurs="unbounded">
                        <xsd:element name="possible_value" type="sacm:PossibleValueType"/>
                        <xsd:element name="possible_restriction" type="sacm:PossibleRestrictionType"/>
                    </xsd:choice>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="PossibleValueType">
        <xsd:annotation>
            <xsd:documentation>The PossibleValueType complex type is used to outline a single expected value of an external variable. The required hint attribute gives a short description of what the value means or represents.</xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:anySimpleType">
                <xsd:attribute name="hint" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>
    <xsd:complexType name="PossibleRestrictionType">
        <xsd:annotation>
            <xsd:documentation>The PossibleRestrictionType complex type outlines a range of possible expected value of an external variable. Each possible_restriction element contains an unbounded list of child restriction elements that each specify a range that an actual value may fall in. For example, a restriction element may specify that a value must be less than 10. When multiple restriction elements are present, a valid possible value's evaluation is based on the operator attribute. The operator attribute is set to AND by default. Other valid operation values are explained in the description of the OperatorEnumeration simple type. One can think of the possible_value and possible_restriction elements as an OR'd list of possible values, with the restriction elements as using the selected operation to evaluate its own list of value descriptions. Please refer to the description of the RestrictionType complex type for more information. The required hint attribute gives a short description of what the value means or represents.</xsd:documentation>
        </xsd:annotation>
        <xsd:choice>
            <xsd:element name="restriction" type="sacm:RestrictionType" minOccurs="1" maxOccurs="unbounded"/>
        </xsd:choice>
        <xsd:attribute name="operator" type="sacm:OperatorEnumeration" use="optional" default="AND"/>
        <xsd:attribute name="hint" type="xsd:string" use="required"/>
    </xsd:complexType>
    <xsd:complexType name="RestrictionType">
        <xsd:annotation>
            <xsd:documentation>The RestrictionType complex type outlines a restriction that is placed on expected values for an external variable. For example, a possible value may be restricted to a integer less than 10. Please refer to the operationEnumeration simple type for a description of the valid operations.</xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:anySimpleType">
                <xsd:attribute name="operation" type="sacm:OperationEnumeration" use="required"/>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>
    <xsd:element name="constant_variable" substitutionGroup="sacm:variable">
        <xsd:annotation>
            <xsd:documentation>The constant_variable element extends the VariableType and defines a variable with a constant value(s). Each constant_variable defines either a single value or a collection of values to be used throughout the evaluation of the OVAL Definition File in which it has been defined. Constant variables cannot be over-ridden by an external source. The actual value of a constant variable is defined by the required value child element. A collection of values can be specified by including multiple instances of the value element. Please refer to the description of the ValueType complex type for more information.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="sacm:VariableType">
                    <xsd:sequence>
                        <xsd:element name="value" type="sacm:ValueType" minOccurs="1" maxOccurs="unbounded"/>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="ValueType">
        <xsd:annotation>
            <xsd:documentation>The ValueType complex type holds the actual value of the variable when dealing with a constant variable. This value should be used by all tests that reference this variable. The value cannot be over-ridden by an external source.</xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:anySimpleType"/>
        </xsd:simpleContent>
    </xsd:complexType>
    <xsd:element name="local_variable" substitutionGroup="sacm:variable">
        <xsd:annotation>
            <xsd:documentation>The local_variable element extends the VariableType and defines a variable with some local source. The actual value(s) for the variable is not provided in the OVAL Definition document but rather it is retrieved during the evaluation of the OVAL Definition. Each local variable is defined by either a single component or a complex function, meaning that a value can be as simple as a literal string or as complex as multiple registry keys concatenated together. Note that if an individual component is used and it returns a collection of values, then there will be multiple values associated with the local_variable. For example, if an object_component is used and it references a file object that identifies a set of 5 files, then the local variable would evaluate to a collection of those 5 values. Please refer to the description of the ComponentGroup for more information.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="sacm:VariableType">
                    <xsd:sequence>
                        <xsd:group ref="sacm:ComponentGroup" />
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:group name="ComponentGroup">
        <xsd:annotation>
            <xsd:documentation>Any value that is pulled directly off the local system is defined by the basic component element. For example, the name of a user or the value of a registry key. Please refer to the definition of the ObjectComponentType for more information. A value can also be obtained from another variable. The variable element identifies a variable id to pull a value(s) from. Please refer to the definition of the VariableComponentType for more information. Literal values can also be specified.</xsd:documentation>
        </xsd:annotation>
        <xsd:choice>
            <xsd:element name="object_component" type="sacm:CollectionComponentType"/>
            <xsd:element name="variable_component" type="sacm:VariableComponentType"/>
            <xsd:element name="literal_component" type="sacm:LiteralComponentType"/>
            <xsd:group ref="sacm:FunctionGroup"/>
        </xsd:choice>
    </xsd:group>
    <xsd:complexType name="LiteralComponentType">
        <xsd:annotation>
            <xsd:documentation>The LiteralComponentType complex type defines a literal value to be used as a component.  The optional datatype attribute defines the type of data expected.  The default datatype is 'string'.</xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:anySimpleType">
                <xsd:attribute name="datatype" type="sacm:SimpleDatatypeEnumeration" use="optional" default="string"/>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>
    <xsd:complexType name="CollectionComponentType">
        <xsd:annotation>
            <xsd:documentation>The ObjectComponentType complex type defines a specific value or set of values on the local system to obtain.</xsd:documentation>
            <xsd:documentation>The required object_ref attribute provides a reference to an existing OVAL Object declaration. The referenced OVAL Object specifies a set of OVAL Items to collect. Note that an OVAL Object might identify 0, 1, or many OVAL Items on a system. If no items are found on the system then an error should be reported when determining the value of an ObjectComponentType. If 1 or more OVAL Items are found then each OVAL Item will be considered and the ObjectComponentType may have one or more values.</xsd:documentation>
            <xsd:documentation>The required item_field attribute specifies the name of the entity whose value will be retrieved from each OVAL Item collected by the referenced OVAL Object. For example, if the object_ref references a win-def:file_object, the item_field may specify the 'version' entity as the field to use as the value of the ObjectComponentType. Note that an OVAL Item may have 0, 1, or many entities whose name matches the specified item_field value. If an entity is not found with a name that matches the value of the item_field an error should be reported when determining the value of an ObjectComponentType. If 1 or more matching entities are found in a single OVAL Item the value of the ObjectComponentType is the list of the values from each of the matching entities.</xsd:documentation>
            <xsd:documentation>The optional record_field attribute specifies the name of a field in a record entity in an OVAL Item. The record_field attribute allows the value of a specific field to be retrieved from an entity with a datatype of 'record'. If a field with a matching name attribute value is not found in the referenced OVAL Item entity an error should be reported when determining the value of the ObjectComponentType.</xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="collection_ref" type="sacm:CollectionIDPattern" use="required"/>
        <xsd:attribute name="item_field" type="sacm:NonEmptyStringType" use="required"/>
        <xsd:attribute name="record_field" type="sacm:NonEmptyStringType" use="optional"/>
    </xsd:complexType>
    <xsd:complexType name="VariableComponentType">
        <xsd:annotation>
            <xsd:documentation>The VariableComponentType complex type defines a specific value obtained by looking at the value of another OVAL Variable. The required var_ref attribute provides a reference to the variable. One must make sure that the variable reference does not point to the parent variable that uses this component to avoid a race condition.</xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="var_ref" type="sacm:VariableIDPattern" use="required"/>
    </xsd:complexType>
    <xsd:group name="FunctionGroup">
        <xsd:annotation>
            <xsd:documentation>Complex functions have been defined that help determine how to manipulate specific values. These functions can be nested together to form complex statements. Each function is designed to work on a specific type of data. If the data being worked on is not of the correct type, a cast should be attempted before reporting an error. For example, if a concat function includes a registry component that returns an integer, then the integer should be cast as a string in order to work with the concat function. Note that if the operation being applied to the variable by the calling entity is "pattern match", then all the functions are performed before the regular expression is evaluated. In short, the variable would produce a value as normal and then any pattern match operation would be performed. It is also important to note that when using these functions with sub-components that return a collection of values that the operation will be performed on the Cartesian
                product of the components and the result is also a collection of values. For example, assume a local_variable specifies the arithmetic function with an arithmetic_operation of "add" and has two sub-components under this function: the first component returns "1" and "2", and the second component returns "3" and "4" and "5". The local_variable element would be evaluated to have a collection of six values: 1+3, 1+4, 1+5, 2+3, 2+4, and 2+5. Please refer to the description of a specific function for more details about it.</xsd:documentation>
        </xsd:annotation>
        <xsd:choice>
            <xsd:element name="arithmetic" type="sacm:ArithmeticFunctionType"/>
            <xsd:element name="begin" type="sacm:BeginFunctionType"/>
            <xsd:element name="concat" type="sacm:ConcatFunctionType"/>
            <xsd:element name="end" type="sacm:EndFunctionType"/>
            <xsd:element name="escape_regex" type="sacm:EscapeRegexFunctionType"/>
            <xsd:element name="split" type="sacm:SplitFunctionType"/>
            <xsd:element name="substring" type="sacm:SubstringFunctionType"/>
            <xsd:element name="time_difference" type="sacm:TimeDifferenceFunctionType"/>
            <xsd:element name="regex_capture" type="sacm:RegexCaptureFunctionType"/>
            <xsd:element name="unique" type="sacm:UniqueFunctionType"/>
            <xsd:element name="count" type="sacm:CountFunctionType"/>
            <xsd:element name="glob_to_regex" type="sacm:GlobToRegexFunctionType"/>
        </xsd:choice>
    </xsd:group>
    <xsd:complexType name="ArithmeticFunctionType">
        <xsd:annotation>
              <xsd:documentation>The arithmetic function takes two or more integer or float components and performs a basic mathematical function on them. The result of this function is a single integer or float unless one of the components returns a collection of values. In this case the specified arithmetic function would be performed multiple times and the end result would also be a collection of values for the local variable. For example assume a local_variable specifies the arithmetic function with an arithmetic_operation of "add" and has two sub-components under this function: the first component returns "1" and "2", and the second component returns "3" and "4" and "5". The local_variable element would be evaluated to be a collection of six values: 1+3, 1+4, 1+5, 2+3, 2+4, and 2+5.</xsd:documentation>
            <xsd:documentation>Note that if both an integer and float components are used then the result is a float.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence minOccurs="2" maxOccurs="unbounded">
            <xsd:group ref="sacm:ComponentGroup"/>
        </xsd:sequence>
        <xsd:attribute name="arithmetic_operation" type="sacm:ArithmeticEnumeration" use="required"/>
    </xsd:complexType>
    <xsd:complexType name="BeginFunctionType">
        <xsd:annotation>
            <xsd:documentation>The begin function takes a single string component and defines a character (or string) that the component string should start with. The character attribute defines the specific character (or string). The character (or string) is only added to the component string if the component string does not already start with the specified character (or string). If the component string does not start with the specified character (or string) the entire character (or string) will be prepended to the component string..</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:group ref="sacm:ComponentGroup"/>
        </xsd:sequence>
        <xsd:attribute name="character" type="xsd:string" use="required"/>
    </xsd:complexType>
    <xsd:complexType name="ConcatFunctionType">
        <xsd:annotation>
            <xsd:documentation>The concat function takes two or more components and concatenates them together to form a single string. The first component makes up the beginning of the resulting string and any following components are added to the end it. If one of the components returns multiple values then the concat function would be performed multiple times and the end result would be a collection of values for the local variable. For example assume a local variable has two sub-components: a basic component element returns the values "abc" and "def", and a literal component element that has a value of "xyz". The local_variable element would evaluate to a collection of two values, "abcxyz" and "defxyz". If one of the components does not exist, then the result of the concat operation should be does not exist.</xsd:documentation>
            <xsd:appinfo>
                <evaluation_documentation>Below is a chart that specifies how to classify the flag status of a variable using the concat function during evaluation when multiple components are supplied. Both the object and variable component are indirectly associated with collected objects in a system characteristics file. These objects could have been completely collected from the system, or there might have been some type of error that led to the object not being collected, or maybe only a part of the object set was collected. This flag status is important as OVAL Objects or OVAL States that are working with a variable (through the var_ref attribute on an entity) can use this information to report more accurate results. For example, an OVAL Test with a check attribute of 'at least one' that specifies an object with a variable reference, might be able to produce a valid result based on an incomplete object set as long as one of the objects in the set is true.</evaluation_documentation>
                <evaluation_chart  xml:space="preserve">
      ||  num of components with flag      || 
      ||                                   || resulting flag is 
      || E  | C  | I  | DNE | NC | NA      || 
------||-----------------------------------||------------------
      || 1+ | 0+ | 0+ | 0+  | 0+ | 0+      || Error
      || 0  | 1+ | 0  | 0   | 0  | 0       || Complete 
      || 0  | 0+ | 1+ | 0   | 0  | 0       || Incomplete 
      || 0  | 0+ | 0+ | 1+  | 0  | 0       || Does Not Exist 
      || 0  | 0+ | 0+ | 0+  | 1+ | 0       || Not Collected 
      || 0  | 0+ | 0+ | 0+  | 0+ | 1+      || Not Applicable
------||-----------------------------------||------------------
                </evaluation_chart>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:sequence minOccurs="2" maxOccurs="unbounded">
            <xsd:group ref="sacm:ComponentGroup"/>
        </xsd:sequence>
    </xsd:complexType>
    <xsd:complexType name="EndFunctionType">
        <xsd:annotation>
            <xsd:documentation>The end function takes a single string component and defines a character (or string) that the component string should end with. The character attribute defines the specific character (or string). The character (or string) is only added to the component string if the component string does not already end with the specified character (or string). If the desired end character is a string, then the entire end string must exist at the end if the component string. If the entire end string is not present then the entire end string is appended to the component string.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:group ref="sacm:ComponentGroup"/>
        </xsd:sequence>
        <xsd:attribute name="character" type="xsd:string" use="required"/>
    </xsd:complexType>
    <xsd:complexType name="EscapeRegexFunctionType">
        <xsd:annotation>
            <xsd:documentation>The escape_regex function takes a single string component and escapes all of the regular expression characters. If the string sub-component contains multiple values, then the escape_regex function will be applied to each individual value and return a multiple-valued result. For example, the string '(\.test_string*)?' will evaluate to '\(\\\.test_string\*\)\?'. The purpose for this is that many times, a component used in pattern match needs to be treated as a literal string and not a regular expression. For example, assume a basic component element that identifies a file path that is held in the Windows registry. This path is a string that might contain regular expression characters. These characters are likely not intended to be treated as regular expression characters and need to be escaped. This function allows a definition writer to mark convert the values of components to regular expression format.</xsd:documentation>
            <xsd:documentation>Note that when using regular expressions, OVAL supports a common subset of the regular expression character classes, operations, expressions and other lexical tokens defined within Perl 5's regular expression specification. The set of Perl metacharacters which must be escaped by this function is as follows, enclosed by single quotes: '^$\.[](){}*+?|'. For more information on the supported regular expression syntax in OVAL see: http://oval.mitre.org/language/about/re_support_5.6.html.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:group ref="sacm:ComponentGroup"/>
        </xsd:sequence>
    </xsd:complexType>
    <xsd:complexType name="SplitFunctionType">
        <xsd:annotation>
            <xsd:documentation>The split function takes a single string component and turns it into a collection of values based on a delimiter string. For example, assume that a basic component element returns the value "a-b-c-d" to the split function with the delimiter set to "-". The local_variable element would be evaluated to have four values "a", "b", "c", and "d". If the basic component returns a value that begins, or ends, with a delimiter, the local_variable element would contain empty string values at the beginning, or end, of the collection of values returned for that string component. For example, if the delimiter is "-", and the basic component element returns the value "-a-a-", the local_variable element would evaluate to a collection of four values "", "a", "a", and "". Likewise, if the basic component element returns a value that contains adjacent delimiters such as "---", the local_variable element would evaluate to a collection of four values "", "", "", and "".
                Lastly, if the basic component element used by the split function returnsa collection of values, then the split function is performed multiple times, and all of the results, from each of the split functions, are returned.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:group ref="sacm:ComponentGroup"/>
        </xsd:sequence>
        <xsd:attribute name="delimiter" type="xsd:string" use="required"/>
    </xsd:complexType>
    <xsd:complexType name="SubstringFunctionType">
        <xsd:annotation>
            <xsd:documentation>The substring function takes a single string component and produces a single value that contains a portion of the original string. The substring_start attribute defines the starting position in the original string. To include the first character of the string, the start position would be 1. A value less than 1 also means that the start position would be 1. If the substring_start attribute has value greater than the length of the original string an error should be reported. The substring_length attribute defines how many characters after, and including, the starting character to include. A substring_length value greater than the actual length of the string, or a negative value, means to include all of the characters after the starting character. For example, assume a basic component element that returns the value "abcdefg" with a substring_start value of 3 and a substring_length value of 2. The local_variable element would evaluate to have a single value
                of "cd". If the string component used by the substring function returns a collection of values, then the substring operation is performed multiple times and results in a collection of values for the component.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:group ref="sacm:ComponentGroup"/>
        </xsd:sequence>
        <xsd:attribute name="substring_start" type="xsd:int" use="required"/>
        <xsd:attribute name="substring_length" type="xsd:int" use="required"/>
    </xsd:complexType>
    <xsd:complexType name="TimeDifferenceFunctionType">
        <xsd:annotation>
            <xsd:documentation>The time_difference function calculates the difference in seconds between date-time values. If one component is specified, the values of that component are subtracted from the current time (UTC). The current time is the time at which the function is evaluated. If two components are specified, the value of the second component is subtracted from the value of the first component. If the component(s) contain a collection of values, the operation is performed multiple times on the Cartesian product of the component(s) and the result is also a collection of time difference values. For example, assume a local_variable specifies the time_difference function and has two sub-components under this function: the first component returns "04/02/2009" and "04/03/2009", and the second component returns "02/02/2005" and "02/03/2005" and "02/04/2005". The local_variable element would evaluate to a collection of six values: (ToSeconds("04/02/2009") - ToSeconds("02/02/2005")), (ToSeconds("04/02/2009") - ToSeconds("02/03/2005")),
                (ToSeconds("04/02/2009") - ToSeconds("02/04/2005")), (ToSeconds("04/03/2009") - ToSeconds("02/02/2005")), (ToSeconds("04/03/2009") - ToSeconds("02/03/2005")), and (ToSeconds("04/03/2009") - ToSeconds("02/04/2005")).</xsd:documentation>
            <xsd:documentation>The date-time format of each component is determined by the two format attributes. The format1 attribute applies to the first component, and the format2 attribute applies to the second component. Valid values for the attributes are 'win_filetime', 'seconds_since_epoch', 'day_month_year', 'year_month_day', and 'month_day_year'. Please see the DateTimeFormatEnumeration for more information about each of these values. If an input value is not understood, the result is an error. If only one input is specified, specify the format with the format2 attribute, as the first input is considered to be the implied 'current time' input.</xsd:documentation>
            <xsd:documentation>Note that the datatype associated with the components should be 'string' or 'int' depending on which date time format is specified.  The result of this function though is always an integer.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence minOccurs="1" maxOccurs="2">
            <xsd:group ref="sacm:ComponentGroup"/>
        </xsd:sequence>
        <xsd:attribute name="format_1" type="sacm:DateTimeFormatEnumeration" use="optional" default="year_month_day"/>
        <xsd:attribute name="format_2" type="sacm:DateTimeFormatEnumeration" use="optional" default="year_month_day"/>
    </xsd:complexType>
    <xsd:complexType name="RegexCaptureFunctionType">
        <xsd:annotation>
            <xsd:documentation>The regex_capture function captures a single substring from a single string component. If the string sub-component contains multiple values, then the regex_capture function will extract a substring from each value. The 'pattern' attribute provides a regular expression that should contain a single subexpression (using parentheses). For example, the pattern ^abc(.*)xyz$ would capture a substring from each of the string component's values if the value starts with abc and ends with xyz. In this case the subexpression would be all the characters that exist in between the abc and the xyz. Note that subexpressions match the longest possible substrings.</xsd:documentation>
            <xsd:documentation>If the regular expression contains multiple capturing sub-patterns, only the first capture is used. If there are no capturing sub-patterns, the result for each target string must be the empty string. Otherwise, if the regular expression could match the target string in more than one place, only the first match (and its first capture) is used. If no matches are found in a target string, the result for that target must be the empty string.</xsd:documentation>
            <xsd:documentation>Note that a quantified capturing sub-pattern does not produce multiple substrings. Standard regular expression semantics are such that if a capturing sub-pattern is required to match multiple times in order for the overall regular expression to match, the capture produced is the last substring to have matched the sub-pattern.</xsd:documentation>
            <xsd:documentation>Note that when using regular expressions, OVAL supports a common subset of the regular expression character classes, operations, expressions and other lexical tokens defined within Perl 5's regular expression specification. If any of the Perl metacharacters are to be used literally, then they must be escaped. The set of metacharacters which must be escaped for this purpose is as follows, enclosed by single quotes: '^$\.[](){}*+?|'. For more information on the supported regular expression syntax in OVAL see: http://oval.mitre.org/language/about/re_support_5.6.html.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:group ref="sacm:ComponentGroup"/>
        </xsd:sequence>
        <xsd:attribute name="pattern" type="xsd:string"/>
    </xsd:complexType>
    <xsd:complexType name="UniqueFunctionType">
        <xsd:annotation>
            <xsd:documentation>The unique function takes one or more components and removes any duplicate value from the set of components. All components used in the unique function will be treated as strings. For example, assume that three components exist, one that contains a string value of 'foo', and two of which both resolve to the string value 'bar'. Applying the unique function to these three components resolves to a local_variable with two string values, 'foo' and 'bar'. Additionally, if any of the components referenced by the unique function evaluate to a collection of values, then those values are used in the unique calculation. For example, assume that there are two components, one of which resolves to a single string value, 'foo', the other of which resolves to two string values, 'foo' and 'bar'. If the unique function is used to remove duplicates from these two components, the function will resolve to a local_variable that is a collection of two string values, 'foo' and
                'bar'.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence maxOccurs="unbounded">
            <xsd:group ref="sacm:ComponentGroup"/>
        </xsd:sequence>
    </xsd:complexType>
    <xsd:complexType name="CountFunctionType">
        <xsd:annotation>
            <xsd:documentation>The count function takes one or more components and returns the count of all of the values represented by the components. For example, assume that two variables exist, each with a single value. By applying the count function against two variable components that resolve to the two variables, the resulting local_variable would have a value of '2'. Additionally, if any of the components referenced by the count function evaluate to a collection of values, then those values are used in the count calculation. For example, assume that there are two components, one of which resolves to a single value, the other of which resolves to two values. If the count function is used to provide a count of these two components, the function will resolve to a local_variable with the values '3'.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence maxOccurs="unbounded">
            <xsd:group ref="sacm:ComponentGroup"/>
        </xsd:sequence>
    </xsd:complexType>
	<xsd:complexType name="GlobToRegexFunctionType">
        <xsd:annotation>
            <xsd:documentation> The glob_to_regex function takes a single string component representing shell glob pattern and produces a single value that corresponds to result of a conversion of the original glob pattern into Perl 5's regular expression pattern. The glob_noescape attribute defines the way how the backslash ('\') character should be interpreted. It defaults to 'false' meaning backslash should be interpreted as an escape character (backslash is allowed to be used as an escape character). If the glob_noescape attribute would be set to 'true' it instructs the glob_to_regex function to interpret the backslash ('\') character as a literal, rather than as an escape character (backslash is *not* allowed to be used as an escape character). Refer to table with examples below to see the difference how a different boolean value of the 'glob_noescape' attribute will impact the output form of the resulting Perl 5's regular expression produced by glob_to_regex function.</xsd:documentation>
            <xsd:documentation>Please note the glob_to_regex function will fail to perform the conversion and return an error when the provided string argument (to represent glob pattern) does not represent a syntactically correct glob pattern. For example given the 'a*b?[' as the argument to be converted, glob_to_regex would return an error since there's missing the corresponding closing bracket in the provided glob pattern argument.</xsd:documentation>
            <xsd:documentation>Also, it is necessary to mention that the glob_to_regex function respects the default behaviour for the input glob pattern and output Perl 5's regular expression spaces. Namely this means that:</xsd:documentation>
            <xsd:documentation>     - glob_to_regex will respect the UNIX glob behavior when processing forward slashes, forward slash should be treated as a path separator and * or ? shall not match it,</xsd:documentation>
            <xsd:documentation>     - glob_to_regex will rule out matches having special meaning (for example '.' as a representation of the current working directory or '..' as a representation of the parent directory of the current working directory,</xsd:documentation>
            <xsd:documentation>     - glob_to_regex will rule out files or folders starting with '.' character (e.g. dotfiles) unless the respective glob pattern part itself starts with the '.' character,</xsd:documentation>
            <xsd:documentation>     - glob_to_regex will not perform case-sensitivity transformation (alphabetical characters will be copied from input glob pattern space to output Perl 5's regular expression pattern space intact). It is kept as a responsibility of the OVAL content author to provide input glob pattern argument in such case so the resulting Perl 5's regular expression pattern will match the expected pathname entries according to the case of preference,</xsd:documentation>
            <xsd:documentation>     - glob_to_regex will not perform any possible brace expansion. Therefore glob patterns like '{pat,pat,pat}' would be converted into Perl 5's regular expression syntax in the original un-expanded form (kept for any potential subsequent expansion to be performed by Perl 5's regular expression engine in the moment of the use of that resulting regular expression),</xsd:documentation>
            <xsd:documentation>     - glob_to_regex will not perform tilde ('~') character substitution to user name home directory pathname. The ('~') character will be passed to Perl 5's regular expression engine intact. If user name home directory pathname glob pattern behaviour is expected, the pathname of the user name home directory needs to be specified in the original input glob pattern already,</xsd:documentation>
            <xsd:documentation>     - glob_to_regex function will not perform any custom changes wrt to the ordering of items (perform any additional sorting of set of pathnames represented by the provided glob pattern argument).</xsd:documentation>
            <xsd:appinfo>
                <evaluation_documentation>Below are some examples that outline how the glob_noescape attribute value affects the output form of the produced Perl regular expression. The far left column identifies the shell glob pattern provided as the input string component to the glob_to_regex function. The middle column specifies the two possible different boolean values of the 'glob_noescape' attribute that can be used. Finally the last column depicts how the output produced by the glob_to_regex function - the resulting Perl regular expression would look like.</evaluation_documentation>
                <evaluation_chart xml:space="preserve">
                          ||                               ||
 input shell glob pattern || glob_noescape attribute value || corresponding Perl regular expression
                          ||                               ||
--------------------------||-------------------------------||--------------------------------------
         '\*'             ||           false               ||                 ^\*$
                          ||-------------------------------||--------------------------------------
         '\*'             ||           true                ||               ^\\[^/]*$
--------------------------||-------------------------------||--------------------------------------
         '\?'             ||           false               ||                 ^\?$
                          ||-------------------------------||--------------------------------------
         '\?'             ||           true                ||              ^\\[^./]$
--------------------------||-------------------------------||--------------------------------------
      '\[hello\]'         ||           false               ||              ^\[hello\]$
                          ||-------------------------------||--------------------------------------
      '\[hello\]'         ||           true                ||            ^\\[hello\\]$
--------------------------||-------------------------------||--------------------------------------
       '/root/*'          ||           false               ||        ^/root/(?=[^.])[^/]*$
                          ||-------------------------------||--------------------------------------
       '/root/.*'         ||           false               ||           ^/root/\.[^/]*$
                          ||-------------------------------||--------------------------------------
       '/root/x*'         ||           false               ||           ^/root/x[^/]*$
                          ||-------------------------------||--------------------------------------
       '/root/?'          ||           false               ||           ^/root/[^./]$
                          ||-------------------------------||--------------------------------------
       '/root/.?'         ||           false               ||           ^/root/\.[^/]$
                          ||-------------------------------||--------------------------------------
       '/root/x?'         ||           false               ||           ^/root/x[^/]$
--------------------------||-------------------------------||--------------------------------------
       'list.?'           ||           false               ||            ^list\.[^/]$
                          ||-------------------------------||--------------------------------------
       'list.?'           ||           true                ||            ^list\.[^/]$
                          ||-------------------------------||--------------------------------------
       'project.*'        ||           false               ||           ^project\.[^/]*$
                          ||-------------------------------||--------------------------------------
       'project.*'        ||           true                ||           ^project\.[^/]*$
                          ||-------------------------------||--------------------------------------
       '*old'             ||           false               ||           ^(?=[^.])[^/]*old$
                          ||-------------------------------||--------------------------------------
       '*old'             ||           true                ||           ^(?=[^.])[^/]*old$
                          ||-------------------------------||--------------------------------------
       'type*.[ch]'       ||           false               ||           ^type[^/]*\.[ch]$
                          ||-------------------------------||--------------------------------------
       'type*.[ch]'       ||           true                ||           ^type[^/]*\.[ch]$
                          ||-------------------------------||--------------------------------------
       '*.*'              ||           false               ||        ^(?=[^.])[^/]*\.[^/]*$
                          ||-------------------------------||--------------------------------------
       '*.*'              ||           true                ||        ^(?=[^.])[^/]*\.[^/]*$
                          ||-------------------------------||--------------------------------------
        '*'               ||           false               ||           ^(?=[^.])[^/]*$
                          ||-------------------------------||--------------------------------------
        '*'               ||           true                ||           ^(?=[^.])[^/]*$
                          ||-------------------------------||--------------------------------------
        '?'               ||           false               ||                ^[^./]$
                          ||-------------------------------||--------------------------------------
        '?'               ||           true                ||                ^[^./]$
                          ||-------------------------------||--------------------------------------
        '\*'              ||           false               ||                 ^\*$
                          ||-------------------------------||--------------------------------------
        '\*'              ||           true                ||               ^\\[^/]*$
                          ||-------------------------------||--------------------------------------
        '\?'              ||           false               ||                 ^\?$
                          ||-------------------------------||--------------------------------------
        '\?'              ||           true                ||               ^\\[^./]$
                          ||-------------------------------||--------------------------------------
   'x[[:digit:]]\*'       ||           false               ||           ^x[[:digit:]]\*$
                          ||-------------------------------||--------------------------------------
   'x[[:digit:]]\*'       ||           true                ||        ^x[[:digit:]]\\[^/]*$
                          ||-------------------------------||--------------------------------------
         ''               ||           false               ||                  ^$
                          ||-------------------------------||--------------------------------------
         ''               ||           true                ||                  ^$
                          ||-------------------------------||--------------------------------------
   '~/files/*.txt'        ||           false               ||    ^~/files/(?=[^.])[^/]*\.txt$
                          ||-------------------------------||--------------------------------------
   '~/files/*.txt'        ||           true                ||    ^~/files/(?=[^.])[^/]*\.txt$
                          ||-------------------------------||--------------------------------------
        '\'               ||           false               ||                 ^\\$
                          ||-------------------------------||--------------------------------------
        '\'               ||           true                ||                 ^\\$
                          ||-------------------------------||--------------------------------------
        '[ab'             ||           false               ||                INVALID
                          ||-------------------------------||--------------------------------------
        '[ab'             ||           true                ||                INVALID
                          ||-------------------------------||--------------------------------------
      '.*.conf'           ||           false               ||           ^\.[^/]*\.conf$
                          ||-------------------------------||--------------------------------------
      '.*.conf'           ||           true                ||           ^\.[^/]*\.conf$
                          ||-------------------------------||--------------------------------------
      'docs/?b'           ||           false               ||            ^docs/[^./]b$
                          ||-------------------------------||--------------------------------------
      'docs/?b'           ||           true                ||            ^docs/[^./]b$
                          ||-------------------------------||--------------------------------------
      'xy/??z'            ||           false               ||            ^xy/[^./][^/]z$
                          ||-------------------------------||--------------------------------------
      'xy/??z'            ||           true                ||            ^xy/[^./][^/]z$
---------------------------------------------------------------------------------------------------
                </evaluation_chart>
            </xsd:appinfo>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:group ref="sacm:ComponentGroup"/>
        </xsd:sequence>
        <xsd:attribute name="glob_noescape" type="xsd:boolean" use="optional" default="false"/>
    </xsd:complexType>

</xsd:schema>
